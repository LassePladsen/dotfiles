#!/bin/bash
symlink_targets=(".bashrc" ".vimrc" ".inputrc" ".fzfrc" ".tmux.conf" ".fzf" ".tmux" ".config/nvim")

repo_path=$( cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd -P )
cd $repo_path

# -f force flag: dont ask to backup & replace files
force=0

# Parse command line options
while getopts "f" opt; do
  case $opt in
    f) force=1 ;;
  esac
done

make_symlinks() {
    for target in "${symlink_targets[@]}"; do
        echo "ln -s $repo_path/$target ~/$target"
        ln -s $repo_path/$target ~/$target > /dev/null 2>&1

        # If failed (file exists), ask to replace it after backup, unless force flag
        if [[  $? -ne 0 && $force -eq 0 ]]; then
            read -p "$target already exists... overwrite it? (y/n) " -s -n 1 answer # wait for input, read one character in silent mode (dont echo typed chars)
            echo ""
        fi

        # Replace if they said yes or used -f flag
        if [[ $force -ne 0 || $answer = 'y' ]]; then
            # Move to backup 
            mkdir -p ~/backup/dotfiles
            mv ~/$target ~/backup/dotfiles/ # > /dev/null 2>&1

            # Create symlink. Nested dirs handled a bit differently
            if [[ $target == *"/"* ]]; then
                ln -s $repo_path/$target "$(dirname ~/$target)" # > /dev/null 2>&1
            else
                ln -s $repo_path/$target ~/$target # > /dev/null 2>&1
            fi
        fi
    done
}

# use stow if installed, else fallback to manually creating symlinks
if command -v stow >/dev/null 2>&1; then 
    git stash
    stow . -t ~ --adopt &&
    git restore .
else
    make_symlinks
fi

